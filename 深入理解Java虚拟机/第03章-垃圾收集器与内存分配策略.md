
<!-- TOC -->

- [1. 第3章 垃圾收集器与内存分配策略](#1-%e7%ac%ac3%e7%ab%a0-%e5%9e%83%e5%9c%be%e6%94%b6%e9%9b%86%e5%99%a8%e4%b8%8e%e5%86%85%e5%ad%98%e5%88%86%e9%85%8d%e7%ad%96%e7%95%a5)
  - [1.1. 概述](#11-%e6%a6%82%e8%bf%b0)
  - [1.2. 对象已死](#12-%e5%af%b9%e8%b1%a1%e5%b7%b2%e6%ad%bb)
    - [1.2.1. 引用计数法](#121-%e5%bc%95%e7%94%a8%e8%ae%a1%e6%95%b0%e6%b3%95)
    - [1.2.2. 可达性分析](#122-%e5%8f%af%e8%be%be%e6%80%a7%e5%88%86%e6%9e%90)
    - [1.2.3. 再谈引用](#123-%e5%86%8d%e8%b0%88%e5%bc%95%e7%94%a8)
    - [1.2.4. 生存还是死亡](#124-%e7%94%9f%e5%ad%98%e8%bf%98%e6%98%af%e6%ad%bb%e4%ba%a1)
    - [1.2.5. 回收方法区](#125-%e5%9b%9e%e6%94%b6%e6%96%b9%e6%b3%95%e5%8c%ba)
  - [1.3. 垃圾收集算法](#13-%e5%9e%83%e5%9c%be%e6%94%b6%e9%9b%86%e7%ae%97%e6%b3%95)
    - [1.3.1. 分代收集理论](#131-%e5%88%86%e4%bb%a3%e6%94%b6%e9%9b%86%e7%90%86%e8%ae%ba)
    - [1.3.2. 标记-清除算法](#132-%e6%a0%87%e8%ae%b0-%e6%b8%85%e9%99%a4%e7%ae%97%e6%b3%95)
    - [1.3.3. 标记-复制算法](#133-%e6%a0%87%e8%ae%b0-%e5%a4%8d%e5%88%b6%e7%ae%97%e6%b3%95)
    - [1.3.4. 标记-整理算法](#134-%e6%a0%87%e8%ae%b0-%e6%95%b4%e7%90%86%e7%ae%97%e6%b3%95)
  - [1.4. HotSpot算法实现细节](#14-hotspot%e7%ae%97%e6%b3%95%e5%ae%9e%e7%8e%b0%e7%bb%86%e8%8a%82)
    - [1.4.1. 根节点枚举](#141-%e6%a0%b9%e8%8a%82%e7%82%b9%e6%9e%9a%e4%b8%be)
    - [1.4.2. 安全点](#142-%e5%ae%89%e5%85%a8%e7%82%b9)
    - [1.4.3. 安全区域](#143-%e5%ae%89%e5%85%a8%e5%8c%ba%e5%9f%9f)
    - [1.4.4. 记忆集与卡表](#144-%e8%ae%b0%e5%bf%86%e9%9b%86%e4%b8%8e%e5%8d%a1%e8%a1%a8)
    - [1.4.5. 写屏障](#145-%e5%86%99%e5%b1%8f%e9%9a%9c)
    - [1.4.6. 并发的可达性分析](#146-%e5%b9%b6%e5%8f%91%e7%9a%84%e5%8f%af%e8%be%be%e6%80%a7%e5%88%86%e6%9e%90)
  - [1.5. 经典垃圾收集器](#15-%e7%bb%8f%e5%85%b8%e5%9e%83%e5%9c%be%e6%94%b6%e9%9b%86%e5%99%a8)
    - [1.5.1. Serial收集器](#151-serial%e6%94%b6%e9%9b%86%e5%99%a8)
    - [1.5.2. ParNew收集器](#152-parnew%e6%94%b6%e9%9b%86%e5%99%a8)
    - [1.5.3. Parallel Scavenge收集器](#153-parallel-scavenge%e6%94%b6%e9%9b%86%e5%99%a8)
    - [1.5.4. Parallel Old收集器](#154-parallel-old%e6%94%b6%e9%9b%86%e5%99%a8)
    - [1.5.5. CMS收集器](#155-cms%e6%94%b6%e9%9b%86%e5%99%a8)
    - [1.5.6. Garbage First收集器](#156-garbage-first%e6%94%b6%e9%9b%86%e5%99%a8)
  - [1.6. 延迟垃圾收集器](#16-%e5%bb%b6%e8%bf%9f%e5%9e%83%e5%9c%be%e6%94%b6%e9%9b%86%e5%99%a8)
    - [1.6.1. Shenandoah收集器](#161-shenandoah%e6%94%b6%e9%9b%86%e5%99%a8)
    - [1.6.2. ZGC](#162-zgc)
  - [1.7. 实战](#17-%e5%ae%9e%e6%88%98)

<!-- /TOC -->
# 1. 第3章 垃圾收集器与内存分配策略

## 1.1. 概述

Java和C++之间有一个动态内存分配和垃圾收集围成的墙，墙外的人想进去，墙里面的人想出来

1960年Lisp是第一门使用内存动态分配和垃圾回收技术的语言, 需要解决三个问题: 哪些内存需要回收、什么时候回收、如何回收

栈帧中分配的内存基本上是在编译期间就已经确定的(运行期间jit编译器可能进行优化)

Java堆和方法区存在着不确定性，接口不同的实现类需要的内存不一样，方法执行不同的分支所需要的内存不一样，这一部分内存需要动态管理和回收



## 1.2. 对象已死

### 1.2.1. 引用计数法

垃圾收集器在对堆内存进行回收前首先要做的事情是判断哪些对象已经“死去”（即该对象不可能通过任何途径使用了）

最简单的方法判断对象是否存活的算法是引用计数法(Reference Counting), 例如微软COM, FlashPlayer,Python等就是使用引用计数方法管理内存

但是单纯的引用技术方法无法解决对象的循环引用问题，至少在Java领域，主流的JVM都没有使用引用计数法进行内存管理的


### 1.2.2. 可达性分析

当前主流的商用编程语言(Java,C#,甚至古老的Lisp)的内存管理算法都是可达性分析(Reachability Analysis)算法来判断对象是否存活

基本思路是通过叫"GC Roots"的根对象作为起始节点，通过引用进行搜索，如果某个对象到GC Roots之间无任何引用链，即在图上不可达则判定对象是不可能在使用的

GC Roots的对象包括
- 虚拟机栈（栈帧中的本地变量表）中引用的对象，例如参数、局部变量、临时变量等
- 在方法区的类静态属性引用的对象
- 在方法区的常量引用的对象，例如字符串常量池中的引用
- 本地方法栈中JNI(Java Native方法接口）引用的变量
- Java虚拟机内部引用，例如基本类型对应的Class对象、常用异常对象、加载器
- 同步锁持有的对象
除了固定的GC Roots集合之外还有其他临时对象加入，例如分代回收和局部回收时的对象可能被位于堆其他区域的对象引用，因此要将关联对象加入到GC Roots集合中

### 1.2.3. 再谈引用

JDK1.2之后，Java对引用进行扩充，引用不再只是指另外一块内存的地址的起始位置，分为强引用、软引用、弱引用、虚引用
- 强引用：程序代码中普遍存在的对象赋值
- 软引用：描述一些还有用但是非必须的对象，在系统发生内存溢出异常之前，会对这些对象进行二次回收，直到回收结束之后仍然无足够内存才会抛出OOM异常
- 弱引用: 描述更弱的非必须对象，关联的对象只能存活到下一次垃圾收集之前，当垃圾收集器工作时这部分对象将会被回收
- 虚引用：一个对象是否存在虚引用对其生存周期无任何影响，无法通过虚引用获取对象实例，关联虚引用的唯一目的是在对象垃圾回收时收到一个系统通知


### 1.2.4. 生存还是死亡

在可达性分析中判定为不可达的对象不是“非死不可”，还是处于“缓刑”，一个对象真正宣告死亡至少要经历两次标记过程
- 第一次标记：在可达性分析后发现到GC Roots没有任何引用链相连时，被第一次标记；并且进行一次筛选：此对象是否必要执行finalize()方法；
  - 没有必要执行的情况：这两种情况就可以认为对象已死，可以回收；
    - 对象没有覆盖finalize()方法；
    - finalize()方法已经被JVM调用过；
  - 有必要执行
    - 对有必要执行finalize()方法的对象，被放入F-Queue队列中；
    - 稍后在JVM自动建立、低优先级的Finalizer线程（可能多个线程）中触发这个方法；
- 第二次标记：
  - GC将对F-Queue队列中的对象进行第二次小规模标记；
  - finalize()方法是对象逃脱死亡的最后一次机会：
    - 如果对象在其finalize()方法中重新与引用链上任何一个对象建立关联，第二次标记时会将其移出"即将回收"的集合；
    - 如果对象没有，也可以认为对象已死，可以回收了；
  - 一个对象的finalize()方法只会被系统自动调用一次，经过finalize()方法逃脱死亡的对象，第二次不会再调用；

任何一个对象的finalize()方法只会被JVM调用一次，下一次面临回收时，finalize()方法不会再次执行，失去了最后一次自救行为

但是在Java程序要避免使用该方法，这是Java刚诞生时的妥协，运行代价高，不确定性大，无法保证各个对象的调用顺序，官方不推荐使用


### 1.2.5. 回收方法区

JVM规范中可以不要求虚拟机在方法区中实现垃圾收集
- 例如JDK11中的ZGC收集器就不支持类卸载
- 因为方法区的类卸载性价比低，例如Java Heap中的新生代一次垃圾收集大概回收70%-99%的空间
- 方法区回收的主要有：废弃的常量和不再使用的类型
  - 常量包括字符串常量池其它接口类、方法、字段中的符号引用
  - 被允许回收的条件非常苛刻, 并且只是允许回收，是否回收还要通过JVM参数参数进行控制
  - 在大量使用反射、动态代理、CGLib等字节码框架或者OSGi等频繁自定义类加载器的场景中需要JVM具备类型卸载能力，保证不会对方法区造成过大内存压力


## 1.3. 垃圾收集算法

### 1.3.1. 分代收集理论

目前商业虚拟机中的垃圾收集器大多数遵循了分代收集理论:
- 弱分代假设：绝大多数对象是朝生夕灭的
- 强分代假设：熬过多次垃圾收集的对象就越难以消灭
- 这两个经验假设表明垃圾收集器需要将Java堆分为不同区域，每次回收只关注少量对象，针对不同区域的对象特征采用不同的垃圾回收算法
- 然而，分代收集理论并不是简单地划分内存区域，因为对象不是孤立的，对象之间可能存在跨代引用
- 跨代引用假设：跨代引用相对于同代引用仅占极少数
- 依照跨代引用假设，不需要扫描整个老年代，只需要在新生代上建立Remembered Set来表示老年代中不同区域的内存是否存在跨代引用
- 当发生Minor GC时，只需要将跨代引用的小块内存里的对象加入到GC Roots进行扫描，而不需要扫描整个老年代

不同的垃圾收集行为:
- Partial GC部分收集：目标不是完整收集整个Java堆，可以分为
  - Minor GC/Young GC新生代收集: 目标只是新生代的对象收集
  - Major GC/Old Gc老年代收集: 目标只是老年代的对象收集, 目前只有CMS会单独收集老年代的行为，Major GC要根据上下文区分是老年代收集还是整堆收集
  - Mixed GC会和收集: 目标是整个新生代和部分老年代的垃圾收集，目前只有G1会有这种行为
- Full GC整堆收集: 收集整个Java堆和方法区的垃圾收集


### 1.3.2. 标记-清除算法

最早的Mark-Sweep算法，分为标记阶段和清扫阶段
- 缺点1：执行效率不稳定，随着对象数量的增多，需要大量的扫描标记时间
- 缺点2：清除阶段会导致大量的不连续的内存碎片，导致之后分配大对象无法遭到连续的足够大的内存而不得不触发另外一次垃圾收集动作

### 1.3.3. 标记-复制算法

为了解决面对大量可回收对象执行效率低的问题，提出了半区复制的算法，将内存分为两块，一块使用，收集时将存活对象复制到另外一块
- 如果内存中的对象大部分存活，会导致复制开销很大，但是大部分都是可回收情况则复制算法只需要复制少量对象，开销较小
- 缺点是将内存可用空间缩小为原来一半，存在空间浪费
- 现在商用JVM大多数采用标记复制算法来回收新生代，因为新生代对象“朝生夕灭”，98%的熬不过第一轮收集，因此不需要按照1:1比例划分内存
- HotSpot虚拟机的Serial ParNew等新生代收集器采用8:1:1的Eden:Survivor:Survivor空间，每新生代可用空间为原来空间的90%
- 当存在一次新生代存活对象数量高于10%即Survivor空间不足以容纳一次Minor GC之后存活的对象时，需要依赖老年代进行分配担保(Handle Promotion), 对象进入老年代

大多数垃圾收集器都使用标记-复制算法来回收新生代, 但是在存活对象较多时复制对象开销太大，并且需要更多担保空间，不太适用于老年代

### 1.3.4. 标记-整理算法

标记复制算法在对象存活率高时需要进行较多复制操作，效率低，并且不想浪费50%的空间时就需要额外的空间进行分配担保，防止存在100%的对象都存活的极端情况,所以老年代一般不适用标记复制算法

标记-整理算法Mark-Compact:
- 针对老年代对象存亡特征，标记过程与“标记-清除”算法一样，只是后续步骤不是直接对可回收对象进行清理，而是让存活对象向内存空间一端进行移动
- 标记清除算法是非移动式的，而标记整理算法是移动式的，两者是一项优缺点并存的风险决策,移动会导致回收更复杂，而不移动导致内存分配更复杂
- 如果移动存活对象，则需要更新所有引用这些对象的地址，并且对象移动操作需要暂停用户程序执行（或者使用读屏障），Stop The World
- 如果不考虑对象的移动和整理，则存活对象会弥散于整个堆，需要使用更加复杂的内存分配器例如分区空闲链表等，这个会导致对于使用最频繁的操作增加额外负担，会直接影响程序的吞吐量
- 不移动对象的停顿时间更短甚至不停顿，从整个程序吞吐量（用户程序和垃圾收集器效率总和）来看移动对象吞吐量更高，因为内存分配的频率远高于垃圾收集的频率，从而导致吞吐量下降
- HotSpot中关注与吞吐量的Parallel Scavenge收集器基于标记-整理算法，而关注与延迟的CMS是基于标记-清除算法
- 两种折中的做法是一般采用标记-清除算法，暂时容忍内存碎片的问题，直到内存碎片影响到大对象的分配时采用标记-整理算法对内存进行规整，基于标记-清除算法的CMS收集器面对空间碎片过多时就是基于这种处理办法.



## 1.4. HotSpot算法实现细节

### 1.4.1. 根节点枚举

固定作为GC Roots的节点主要是全局性的引用（常量和静态变量）和执行上下文（栈帧中的局部变量表）
- 方法区的大小有上百兆，类和常量非常多，逐个检查无法做到高效查找
- 所有的收集器(包括G1,CMS,ZGC)在根节点枚举步骤必须要暂停用户线程，Stop The World, 根节点要在一个保证一致性的快照节点才得以执行, 即所有线程的根节点引用不再发生变化
- HotSpot使用OopMap数据结构来直接得到哪些地方存在对象引用，即时编译器也会在特定区域记录栈中和寄存器哪些位置是引用，收集器可以直接得到并不需要扫描整个方法区
- 生成本地方法时call指令可以记录OopMap{ebx=Oop [16]=Oop off=142}表明EBX和栈中偏移量为16的位置各有一个Oop(普通对象指针), 有效范围从call指令开始到之后的142个指令

### 1.4.2. 安全点

GC Roots不断变化
- OopMap可以帮助HotSpot快速的完成GC Roots枚举, 但是程序运行过程中引用关系可能发生变化
- 部分指令可能引用OopMap变化，因此无法为每一条指令都生成OopMap，防止巨额空间成本
- HotSpot只在安全点SafePoint的代码位置生成OopMap，因此GC并非在任何指令位置停下来可以进行垃圾收集，而是强制要求必须执行到安全点后才能暂停
- 安全点位置原则是指令序列的复用，例如方法调用、循环跳转、异常跳转功能的指令才会产生安全点，生成对应的OopMap

如何让所有线程在GC时都停留在最近的安全点
- 抢先式中断: 垃圾收集时直接暂停所有线程，然后发现存在不在安全点的线程时，就恢复这个线程让它执行到安全点, 现在几乎没有JVM采用抢先式中断响应GC事件
- 现在JVM普遍采用主动式中断的方式，GC需要暂停用户线程时，不直接对线程进行操作，只是设置一个标志位
- HotSpot将某个内存页为不可读标志，各个线程在安全点时会去轮旋这个标志，HotSpot采用test指令方位这个内存页时产生缺页异常
- 在预先注册的异常处理器中挂起线程等待，这样只通过一条指令即可完成安全点轮询和触发线程中断停止

### 1.4.3. 安全区域

安全点保证了程序在执行时可以在不太长时间内就可以进入到垃圾收集过程的安全点
- 对于程序不执行例如线程阻塞状态时线程无法响应JVM的中断请求, 不能走到安全点挂起自己，这时需要引入安全区域Safe Region解决
- 安全区域值引用关系不会发生变化的一段代码片段，这个区域任何指令位置进行垃圾收集都是安全的,是扩展的安全点
- 当线程执行到安全区域代码时，对自己状态进行标识，JVM发起垃圾收集时不管这些线程，因为处于安全区域的线程引用关系不变
- 当线程离开安全区域时，检查虚拟机是否完成根节点枚举或者其他暂停线程的阶段
- 如果没有则需要等待直到收到可以离开安全区域的信号，否则可以继续执行

### 1.4.4. 记忆集与卡表

分代收集理论中为了解决跨代引用问题，GC在新生代中建立了记忆集RememberedSet的数据结构避免将真个老年代加入到GC Roots扫描

记忆集是记录从非收集区域指向收集区域的指针集合的抽象数据结构，HotSpot采用卡表CardTable方式实现记忆集，每个记录精确到一个内存区域，表明该区域某个对象包含跨代指针

HotSpot默认的卡表元素对应的大小为512字节一个卡页, 这一页内存中只要一个对象包含跨代指针，就数组元素就为1，否则为0

在垃圾收集时，只要筛选卡表中变脏(1)的元素，将其加入到GC Roots中一并扫描, 以空间换时间

### 1.4.5. 写屏障

使用记忆集减少GC Roots扫描范围问题，使用写屏障解决卡表的维护和更新问题

何时变脏：变脏的时间点是在发生引用类型赋值的指令

如何变脏:
- 对于解释执行，则虚拟机负责字节码指令的执行，有充分的的介入空间
- 对于编译执行，则需要在机器代码层面将维护卡表的动作放入到每个赋值操作之中
- HotSpot采用写屏障Write Barrier维护卡表状态

写屏障:
- 写屏障可以看成对于对象引用赋值动作的AOP切面，在赋值前的称为写前屏障，在赋值后称为写后屏障，G1收集器出现之前JVM只使用写后屏障
- 应用写后屏障时，虚拟机为所有的复制操作指令oop_field_store指令生成对应的AOP指令
- 缺点1: 每次进行引用更新都会产生额外开销，但是对于Minor GC扫描真个老年代相比代价低得多
- 缺点2: 存在伪共享问题，即当多个线程操作多个的独立变量共享于同一个缓存行，会相互影响（写回、无效等）导致性能降低
  - 例如缓存行大小为64字节，一个卡表元素占用一个字节，64个卡表元素共享一个缓存行，则32KB内存中同时存在多个引用更新会导致性能降低
  - 解决办法是不采用无条件的写屏障，而是先检查卡表状态，只有卡表状态不是过时才将其变为脏

### 1.4.6. 并发的可达性分析

可达性算法需要全过程都基于一个保障一致性的快照中才能进行分析
- 在根节点枚举中，GC Roots数量和堆大小无关，并且相对于对象数量来说较少，在各种优化(OopMap)的停顿时间非常短暂且固定（不随着堆增长而增加）
- 从GC Roots下进行遍历对象图，停顿时间随着Java堆容量成正比关系, 停顿时间会线性增长
- 标记是所有追踪式收集器的共同特征，因此需要减少这部分停顿时间
- 遍历对象图的过程中，用户线程可能并发修改对象图结构，黑白表示有引用和无引用的对象，则并发修改可能白色被标记为黑色（可以容忍下次收集），可能黑色被标记为白色（不可容忍致命错误）
- Wilson 1994年证明只有同时满足一下才会将黑色对象误标记为白色对象（1）插入从黑色到白色的新引用（2）删除全部从灰色到白色的所有引用

解决赋值器（用户程序）并发扫描时的对象消失问题,只需要破坏任意一个条件：
- 增量更新(Incremental Update):
  - 破坏条件1
  - 当黑色对象插入了指向白色的引用就记录下来，并发扫描结束时将记录过的引用中黑色对象为根重新扫描
  - 即黑色对象插入了指向白色对象的引用，就将其变为灰色对象，重新扫描
- 原始快照(Snapshot At The Beginning, SATB):
  - 破坏条件2
  - 当灰色对象删除指向白色对象的引用时，记录这些引用，并发扫描时以这些灰色对象为根重新扫描
  - 即无论引用关系是否删除，按照刚开始扫描那一刻的对象图快照进行
- 对于引用关系删除和插入的记录都是通过写屏障记录的, HotSpot中CMS基于增量更新进行并发标记，而G1, Shenandoah使用原始快照进行并发标记


## 1.5. 经典垃圾收集器

垃圾收集算法是内存回收的方法论，垃圾收集器是内存回收的实践者, JVM规范中对于垃圾收集器如何实现没有任何规定
- 新生代: Serial、ParNew、Parallel Scavenge
- 老年代: CMS、Serial Old、Parallel Old
- 全局: G1
- 主要组合: ParNew + CMS、Parallel Scavenge + Parallel Old、G1

### 1.5.1. Serial收集器

Serial 的意思是在进行垃圾回收时会暂停其他所有线程的运行
- Serial新生代采用复制算法，在安全点时暂停所有用户线程执行
- Serial Old工作于老年代，采用标记整理算法暂停所有用户线程，这是老版本使用的，并且作为CMS收集器失败的预案
- Stop The World表示GC线程工作时其他用户线程暂停，直到GC线程收集结束
- 随着JDK1.3-JDK17，垃圾收集器越来越复杂，但是用户线程的停顿时间在持续缩短，但是无法彻底消除

### 1.5.2. ParNew收集器

ParNew收集器是Serial收集器的多线程版本, 回除了使用多线程收集之外，很多行为和Serial完全一致
- JDK7以前系统首选的新生代垃圾收集器，除了Serial之外，只有它可以与CMS收集配合使用
- JDK9以后，ParNew+CMS的组合以及不在是官方推荐使用的，完全被G1所取代

### 1.5.3. Parallel Scavenge收集器

Parallel Scavenge是工作于新生代的收集器，使用标记-复制算法，能够并行多线程收集
- 关注点和其他收集器不同在于是达到可控的吞吐量(运行用户代码时间和垃圾收集时间的比值)
- 高吞吐量意味着整体上效率高，例如计算量大的后台进程，而停顿时间段则适合与用户交互的服务程序
- 垃圾收集停顿时间缩短是通过牺牲吞吐量和新生代空间换取的，新生代越小，停顿时间越短，但是收集更加频繁，例如500M空间10s一次停顿100ms,300M空间5s停顿一次70ms, 停顿时间减少但是吞吐量也降低
- Parallel Scavenge是吞吐量优先收集器，可以自适应的根据当前运行情况调整新生代比例，Eden和Survivor比例等参数，将内存调优交给PS自动完成
- 自适应调节策略是Parallel Scavenge收集器区别ParNew的一个重要特征

### 1.5.4. Parallel Old收集器

Parallel Old是Parallel Scavenge收集器的老年代版本, 支持多线程并发收集, 基于标记-整理算法

在注重吞吐量或者处理器资源比较稀缺的情况下可以使用Parallel Scavenge + Parallel Olld收集器组合

Java默认参数会使用UseParallelGC
- -XX:+UseParallelGC: Parallel Scavenge + Serial Old
- 从JDK7u4开始，就对 “-XX:+UseParallelGC” 默认的老年代收集器进行了改进，HotSpot VM在选择使用 “-XX:+UseParallelGC” 时，会默认开启 " -XX:+UseParallelOldGC “，也就是说默认的老年代收集器是 Parallel Old。
- JDK8默认的垃圾收集器是: Parallel Scavenge + Parallel Old
- cms从来没有成为default gc策略，parallel之后是g1，JDK9中g1称为默认，而CMS变为deprecated，在JDK14中删除

### 1.5.5. CMS收集器

CMS(Concurrent Mark Sweep)收集器是以最短回收停顿时间为目标的收集器, 例如基于互联网网站或者B/S架构的服务器端关注响应速度，提供良好的交互体验
- 包含初始标记、并发标记、重新标记、并发清除四个阶段，其中初始标记和重新标记需要Stop the world
- 初始标记就是标记GC Roots能够直接关联的对象
- 并发标记就是从GC Roots直接关联的对象开始遍历整个对象图的过程，耗时较长但是不需要停顿可以并行
- 重新标记是为了解决并发标记中用户程序对引用关系的修正, 这一阶段停顿通常比初始标记阶段长一些，但是远比并发标记短
- 并发清除将清理删除掉标记为已死亡的对象，由于不需要移动存活对象，此阶段可以和用户程序并行
- 整个过程中耗时最长的是并发标记和并发清理,这两个阶段GC线程和用户线程可以并发执行的，整体来说CMS的内存回收过程是和用户线程一起并发工作的


CMS收集器是HotSpot追求低停顿的第一次尝试，但是远不到完美的程度，存在是三个明显缺点：
- CMS对处理器资源非常敏感，虽然用户线程停顿时间很短，但是会长时间占用处理器资源导致用户程序变慢，降低总吞吐量，特别是对于CPU数量少于4时
- CMS无法处理浮动垃圾，有可能出现Concurrent Mode Failure失败导致另外一次完全STW的Full GC
  - 在并发标记和并发清理阶段用户线程仍然运行，一部分垃圾是在标记结束之后产生的，CMS无法在当次收集中处理，只能将这些浮动垃圾留在下次收集
  - 因此需要预留一部分空间在并发收集时给用户程序需使用，JDK5中CMS老年代使用68%就会激活CMS，导致内存回收频率过，高性能降低
  - JDK6中CMS启动阈值提高到92%,但是太高的阈值导致CMS在运行期间预留内存可能无法满足分配新对象的需要导致出现并发失败(Concurrent Mode Failure)
  - 这样需要启动后被方案，冻结用户线程执行，使用Serial Old来重新进行老年代的垃圾收集，停顿时间变长，性能降低
- CMS基于标记清除算法导致出现内存碎片
  - 空间碎片会导致大对象的分配出现问题，存在有很多剩余空间但是无法分配足够的连续空间而导致提前产生Full GC问题
  - CMS提供参数在Full GC时开启内存碎片整理合并过程，也可以设置在执行若干不整理空间的Full GC之后，下一次进入Full GC前先进行碎片整理

```
CPU 0 ===>用户线程1  |               |   ===> 用户线程1 | ---->重新标记 | ===>用户线程1 | ===>用户线程1
CPU 1 ===>用户线程2  | ---->初始标记  |   ===> 用户线程2 | ---->重新标记 | ===>用户线程2 | ===>用户线程2
CPU 2 ===>用户线程3  |               |   ---->并发标记  | ---->重新标记 | ---->并发清理 | ===>用户线程3
CPU 3 ===>用户线程4  |               |   ===> 用户线程4 | ---->重新标记 | ===>用户线程4 | ===>用户线程4
```


### 1.5.6. Garbage First收集器

G1(Garbage First)收集器是JVM GC技术发展历史上的里程碑式的成果,开创了**面向局部收集**的设计思路和**基于Region的内存布局**形式. JDK 6 Update 14就有Early Access的G1, JDK 7 Update 4, Oracle才移除Experimental标志，足够成熟面向商用，到JDK 8 Update 40, G1提供类卸载支持，此后G1收集器才被Oracle官方称为"全能的垃圾收集器", 在JDK9中G1取代了Parallel Scavenge + Parallel Old的组合，成为服务器端默认的垃圾收集器,CMS标记为不推荐使用

G1
- G1作为CMS的替代者和继承人，目标是建立一个停顿时间模型，面向堆内存任何部分组成回收机CSet，衡量标准为哪块内存存放的垃圾最多收益最大，而不是哪个分代
- G1开创基于Region的内存布局, 将堆内存划分为1~32MB的可设置的Region，不同Region扮演不同的分代角色,还包括存储大对象的Humongous区域
- G1将Region作为单次回收最小单元，避免整个堆的全区域收集，让G1最终每个区域中垃圾堆积的价值大小，建立模型，维护一个优先级列表，优先处理回收价值大的区域
- 使用基于Region的划分方式，以及具有优先级的回收方式，保证G1收集器在有限停顿时间可以获得较高的效率

G1模型在2004年论文发表，直到2012年4月JDK 7 Update4发布，存在很多需要解决和完善的细节
- Region存在跨引用问题: 记忆集使用HashMap解决，Key为Region起始地址, value为执行自己的所有Region索引, 本质是双向卡表，实现复杂，并且Region数量过多，导致G1收集器比传统需要占用更多内存，经验表明G1需要占用Heap的10%~20%来维持内存管理和垃圾收集工作
- 并发标记阶段的互不干扰: CMS采用增量更新，G1采用原始快照实现, G1为每一个Region使用TAMS(To At Mark Start)指针, 并发回收新分配的对象的地址必须要要在指针之上, 此地址上的对象不纳入回收范围, 同样可能因为内存回收速率慢于内存分配速率导致用户线程冻结，进行Full GC导致长时间的Stop The World
- 建立可靠的停顿预测模型: 以均值衰减，记录每个Region回收耗时、脏卡表数量等成本，分析均值、标准差、置信度等统计信息，通过这些信息预测现在开始回收时，哪些Region组成的CSet可以在不超过期望最低预测时间的约束下获得最高收益

G1执行步骤大致过程
- 初始标记：标记GC Roots能直接关联的对象, 修改TAMS指针让下一阶段用户程序并发执行可分配新对象, 这个时间停顿时间很短
- 并发标记：从GC Roots直接关联的对象开始对象图遍历，耗时较长，但是可以并发执行，同时在并发处理结束时需要重新处理SATB记录下变动的对象引用关系
- 最终标记：对用户线程做短时间停顿，用于处理并发阶段遗留的少量的SATB记录
- 筛选回收：负责更新Region统计数据，对各个Region的回收价值和成本排序，根据期望的停顿时间制定回收计划，并且将回收集中所有Region中存活的对象复制到空的Region中，涉及到存活对象的移动必须要暂停用户线程，这一部分没有与用户程序并发执行，因为过于复杂，并且G1只是回收部分空间，停顿时间可控，而是把这一部分特性放到之后的低延迟垃圾收集器(ZGC）中


```
CPU 0 ===>用户线程1  |               |   ===> 用户线程1 | ---->最终标记 | ---->筛选回收 | ===>用户线程1
CPU 1 ===>用户线程2  | ---->初始标记  |   ===> 用户线程2 | ---->最终标记 | ---->筛选回收 | ===>用户线程2
CPU 2 ===>用户线程3  |               |   ---->并发标记  | ---->最终标记 | ---->筛选回收 | ===>用户线程3
CPU 3 ===>用户线程4  |               |   ===> 用户线程4 | ---->最终标记 | ---->筛选回收 | ===>用户线程4
```

G1垃圾收集器的期望停顿时间为毫秒级别，几十毫秒到一百毫秒甚至两百毫秒，设置过小可能导致分配速率高于回收速率最终导致Full GC
- G1开始的垃圾收集器都是以可以应付的内存分配速率为导向而不需要一次将整个堆清理干净
- G1整体上是按照标记-整理算法，局部（两个Region之间）按照标记-复制算法，相对于CMS不会产生内存碎片，有利于程序长时间稳定执行
- G1的缺点是为了垃圾收集产生的内存占用还是程序运行的额外执行负载比CMS高很多
  - 内存占用方面：G1为每个Region维护卡表，数量过多，可能占用整个堆内存的20%甚至更多，而CMS只需要维护唯一一份卡表，并且是从老年代指向新生代的单向引用
  - 执行负载方面：CMS使用写后屏障维护卡表，G1会用更复杂的写后屏障维护，为了实现原始快照算法，同时使用写前屏障来追踪并发指针修改，虽然可以减少停顿时间过长的缺点，但是会带来额外负担，消耗更多的计算资源
- 小内存上CMS可能优于G1, 在大内存上G1可以更好的发挥优势，平衡点大概在6GB-8GB之间

## 1.6. 延迟垃圾收集器

衡量垃圾收集器的三个指标：
- 内存占用Footprint
- 吞吐量Throughtput
- 延迟Latency：日益重要，随着硬件发展，内存和吞吐量会越来越大，但是延迟会随着内存增长而带来负面影响，因此延迟延迟主键称为最重要的因素

### 1.6.1. Shenandoah收集器

SGC是Redhat开发在2014年贡献到OpenJDK中，相对于G1, 不仅实现并发标记，还要实现并发的对象清理
- G1的回收阶段需要STW，而SGC采用转发指针方式可以做到在回收阶段和用户程序并发执行
- SGC默认不采用分代收集，即Region没有区分不同的新生代或者老年代
- SGC放弃了在G1中使用大量内存和计算资源维护的记忆集，而是采用连接矩阵(二维数组)的全局数据结构维护跨Region引用

步骤:
- 初始标记，并发标记，最终标记，并发清理
- 并发回收：SGC与前面最大的区别，移动对象是一次行为，但是所有引用此对象都还是旧地址, SGC通过读屏障和转发指针解决
- 初始引用更新: 并发回收阶段结束将堆中所有指向就对象的引用更新到复制后的新地址,可以与用户程序并发执行
- 最终引用更新：解决堆中引用更新后需要修改GC Roots中的引用更新，这是最后一次停顿，和GC Roots成正比
- 并发清理：并发回收和引用更新之后，整个回收集Region无存活对象，可以直接并发清理这些内存

转发指针：
- 原有实现对象移动和用户程序并发的解决方案，需要在原有对象内存上设置保护陷阱，访问则产生中断，将代码逻辑吧访问转发到新的对象上，但是如果无操作系统层面支持，会导致频繁的用户态-核心态切换，成本过高
- 1984年Brooks提出转发指针，在原有对象Object header前加上一个新的引用字段，正常不并发移动的对象的Brooks引用指向自己
- 转发指针分散于每个对象头前面，每次间接访问会产生额外一条指令的代价，通过CAS保证并发访问的修改，相对于中断方式代价会低很多
- 为了实现Brooks Pointer，SGC在读写屏障中都加入了转发处理，尤其是读屏障频率高，代价更大, 性能开销是SGC被诟病的关键点之一
-


### 1.6.2. ZGC

ZGC采用动态Region，并且采用染色指针，在停顿时间上无论平均停顿，95%停顿,99停顿还是最大停顿都能控制在10ms之内，和Parallel Scavenge、G1等拉开两个数量级差距，吞吐量超过G1，并且非常接近以吞吐量为目标的Parallel Scavenge

染色指针：
- 在64位系统，x86-64架构支持52为地址总线和48位(256TB)的虚拟地址空间, 因此实际支持最大内存是256TB, 并且Linux(46位)和Windows(44位)本身都会加上更多限制
- Linux下64位系统高18位不能寻址，剩下的46位仍然支持大型服务器，ZGC利用剩下的46位宽度指针，将其高4位存储四个标志信息
- 通过这四个标志位，JVM可以直接从指针中看到其引用对象的三色标记状态、是否移动、是否被finalize()方法访问，导致ZGC只能管理42位4TB内存, 不支持32位系统


## 1.7. 实战

对象优先分配在Eden区

大对象直接进入老年代

长期存活对象进入老年代

动态对象年龄判断

空间分配担保
