

# 1. 第3章 垃圾收集器与内存分配策略

## 1.1. 概述

Java和C++之间有一个动态内存分配和垃圾收集围成的墙，墙外的人想进去，墙里面的人想出来

1960年Lisp是第一门使用内存动态分配和垃圾回收技术的语言, 需要解决三个问题: 哪些内存需要回收、什么时候回收、如何回收

栈帧中分配的内存基本上是在编译期间就已经确定的(运行期间jit编译器可能进行优化)

Java堆和方法区存在着不确定性，接口不同的实现类需要的内存不一样，方法执行不同的分支所需要的内存不一样，这一部分内存需要动态管理和回收



## 1.2. 对象已死

### 1.2.1. 引用计数法

垃圾收集器在对堆内存进行回收前首先要做的事情是判断哪些对象已经“死去”（即该对象不可能通过任何途径使用了）

最简单的方法判断对象是否存活的算法是引用计数法(Reference Counting), 例如微软COM, FlashPlayer,Python等就是使用引用计数方法管理内存

但是单纯的引用技术方法无法解决对象的循环引用问题，至少在Java领域，主流的JVM都没有使用引用计数法进行内存管理的


### 1.2.2. 可达性分析

当前主流的商用编程语言(Java,C#,甚至古老的Lisp)的内存管理算法都是可达性分析(Reachability Analysis)算法来判断对象是否存活

基本思路是通过叫"GC Roots"的根对象作为起始节点，通过引用进行搜索，如果某个对象到GC Roots之间无任何引用链，即在图上不可达则判定对象是不可能在使用的

GC Roots的对象包括
- 虚拟机栈（栈帧中的本地变量表）中引用的对象，例如参数、局部变量、临时变量等
- 在方法区的类静态属性引用的对象
- 在方法区的常量引用的对象，例如字符串常量池中的引用
- 本地方法栈中JNI(Java Native方法接口）引用的变量
- Java虚拟机内部引用，例如基本类型对应的Class对象、常用异常对象、加载器
- 同步锁持有的对象
除了固定的GC Roots集合之外还有其他临时对象加入，例如分代回收和局部回收时的对象可能被位于堆其他区域的对象引用，因此要将关联对象加入到GC Roots集合中

### 1.2.3. 再谈引用

JDK1.2之后，Java对引用进行扩充，引用不再只是指另外一块内存的地址的起始位置，分为强引用、软引用、弱引用、虚引用
- 强引用：程序代码中普遍存在的对象赋值
- 软引用：描述一些还有用但是非必须的对象，在系统发生内存溢出异常之前，会对这些对象进行二次回收，直到回收结束之后仍然无足够内存才会抛出OOM异常
- 弱引用: 描述更弱的非必须对象，关联的对象只能存活到下一次垃圾收集之前，当垃圾收集器工作时这部分对象将会被回收
- 虚引用：一个对象是否存在虚引用对其生存周期无任何影响，无法通过虚引用获取对象实例，关联虚引用的唯一目的是在对象垃圾回收时收到一个系统通知


### 1.2.4. 生存还是死亡

在可达性分析中判定为不可达的对象不是“非死不可”，还是处于“缓刑”，一个对象真正宣告死亡至少要经历两次标记过程
- 第一次通过可达性不可达，则进行第一次标记，随后进行筛选是否有必要执行此对象的finalize()方法
  - 条件是对象没有覆盖该方法
  - 或者finalize()已经被虚拟机调用过
  - 则JVM将这两种情况视为没有必要执行
- 如果对象被判定为必要执行finalize()方法
  - 则将该对象放入F-Queue队列中
  - 稍后由JVM创建的低优先级线程Finalizer去执行它们的finalize()方法
  - 执行指的是JVM会触发这个方法开始运行，但是不保证一定会等待其运行结束，防止某个对象finalize方法运行时间过长导致F-Queue其他对象等待
- finalize()方法是对象逃脱死亡的最后一次机会
  - 收集器会对F-Queue中的对象进行第二次小规模标记
  - 如果对象在finalize方法中拯救自己，例如覆盖该方法并与引用连上的某一个对象关联，则第二次标记时会被移除F-Queue
  - 如果对象没有逃脱，则将会被回收

任何一个对象的finalize()方法只会被JVM调用一次，下一次面临回收时，finalize()方法不会再次执行，失去了最后一次自救行为

但是在Java程序要避免使用该方法，这是Java刚诞生时的妥协，运行代价高，不确定性大，无法保证各个对象的调用顺序，官方不推荐使用


### 1.2.5. 回收方法区

JVM规范中可以不要求虚拟机在方法区中实现垃圾收集
- 例如JDK11中的ZGC收集器就不支持类卸载
- 因为方法区的类卸载性价比低，例如Java Heap中的新生代一次垃圾收集大概回收70%-99%的空间
- 方法区回收的主要有：废弃的常量和不再使用的类型
  - 常量包括字符串常量池其它接口类、方法、字段中的符号引用
  - 被允许回收的条件非常苛刻, 并且只是允许回收，是否回收还要通过JVM参数参数进行控制
  - 在大量使用反射、动态代理、CGLib等字节码框架或者OSGi等频繁自定义类加载器的场景中需要JVM具备类型卸载能力，保证不会对方法区造成过大内存压力


## 1.3. 垃圾收集算法

### 1.3.1. 分代收集理论

目前商业虚拟机中的垃圾收集器大多数遵循了分代收集理论:
- 弱分代假设：绝大多数对象是朝生夕灭的
- 强分代假设：熬过多次垃圾收集的对象就越难以消灭
- 这两个经验假设表明垃圾收集器需要将Java堆分为不同区域，每次回收只关注少量对象，针对不同区域的对象特征采用不同的垃圾回收算法
- 然而，分代收集理论并不是简单地划分内存区域，因为对象不是孤立的，对象之间可能存在跨代引用
- 跨代引用假设：跨代引用相对于同代引用仅占极少数
- 依照跨代引用假设，不需要扫描整个老年代，只需要在新生代上建立Remembered Set来表示老年代中不同区域的内存是否存在跨代引用
- 当发生Minor GC时，只需要将跨代引用的小块内存里的对象加入到GC Roots进行扫描，而不需要扫描整个老年代

不同的垃圾收集行为:
- Partial GC部分收集：目标不是完整收集整个Java堆，可以分为
  - Minor GC/Young GC新生代收集: 目标只是新生代的对象收集
  - Major GC/Old Gc老年代收集: 目标只是老年代的对象收集, 目前只有CMS会单独收集老年代的行为，Major GC要根据上下文区分是老年代收集还是整堆收集
  - Mixed GC会和收集: 目标是整个新生代和部分老年代的垃圾收集，目前只有G1会有这种行为
- Full GC整堆收集: 收集整个Java堆和方法区的垃圾收集


### 1.3.2. 标记-清除算法

最早的Mark-Sweep算法，分为标记阶段和清扫阶段
- 缺点1：执行效率不稳定，随着对象数量的增多，需要大量的扫描标记时间
- 缺点2：清除阶段会导致大量的不连续的内存碎片，导致之后分配大对象无法遭到连续的足够大的内存而不得不触发另外一次垃圾收集动作

### 1.3.3. 标记-复制算法

为了解决面对大量可回收对象执行效率低的问题，提出了半区复制的算法，将内存分为两块，一块使用，收集时将存活对象复制到另外一块
- 如果内存中的对象大部分存活，会导致复制开销很大，但是大部分都是可回收情况则复制算法只需要复制少量对象，开销较小
- 缺点是将内存可用空间缩小为原来一半，存在空间浪费
- 现在商用JVM大多数采用标记复制算法来回收新生代，因为新生代对象“朝生夕灭”，98%的熬不过第一轮收集，因此不需要按照1:1比例划分内存
- HotSpot虚拟机的Serial ParNew等新生代收集器采用8:1:1的Eden:Survivor:Survivor空间，每新生代可用空间为原来空间的90%
- 当存在一次新生代存活对象数量高于10%即Survivor空间不足以容纳一次Minor GC之后存活的对象时，需要依赖老年代进行分配担保(Handle Promotion), 对象进入老年代

### 1.3.4. 标记-整理算法

标记复制算法在对象存活率高时需要进行较多复制操作，效率低，并且不想浪费50%的空间时就需要额外的空间进行分配担保，防止存在100%的对象都存活的极端情况,所以老年代一般不适用标记复制算法

标记-整理算法Mark-Compact:
- 针对老年代对象存亡特征，标记过程与“标记-清除”算法一样，只是后续步骤不是直接对可回收对象进行清理，而是让存活对象向内存空间一端进行移动
- 标记清除算法是非移动式的，而标记整理算法是移动式的，两者是一项优缺点并存的风险决策,移动会导致回收更复杂，而不移动导致内存分配更复杂
- 如果移动存活对象，则需要更新所有引用这些对象的地址，并且对象移动操作需要暂停用户程序执行，Stop The World
- 如果不考虑对象的移动和整理，则存活对象会弥散于整个堆，需要使用更加复杂的内存分配器例如分区空闲链表等，这个会导致对于使用最频繁的操作增加额外负担，会直接影响程序的吞吐量
- 不移动对象的停顿时间更短甚至不停顿，从整个程序吞吐量（用户程序和垃圾收集器效率总和）来看移动对象吞吐量更高，因为内存分配的频率远高于垃圾收集的频率，从而导致吞吐量下降
- HotSpot中关注与吞吐量的Parallel Scavenge收集器基于标记-整理算法，而关注与延迟的CMS是基于标记-清除算法
- 两种折中的做法是一般采用标记-清除算法，，暂时容忍内存碎片的问题，直到内存碎片影响到大对象的分配时采用标记-整理算法对内存进行规整，基于标记-清除算法的CMS收集器面对空间碎片过多时就是基于这种处理办法.



## 1.4. HotSpot算法实现细节

### 1.4.1. 根节点枚举

固定作为GC Roots的节点主要是全局性的引用（常量和静态变量）和执行上下文（栈帧中的局部变量表）
- 方法区的大小有上百兆，类和常量非常多，逐个检查无法做到高效查找
- 所有收集器(包括G1,CMS,ZGC)在根节点枚举步骤必须要暂停用户线程，Stop The World, 根节点要在一个保证一致性的快照节点才得以执行, 根节点引用不再发生变化
- HotSpot使用OopMap数据结构来直接得到哪些地方存在对象引用，即时编译器也会在特定区域记录栈中和寄存器哪些位置是引用，收集器可以直接得到并不需要扫描整个方法区
- 生成本地方法时call指令可以记录OopMap{ebx=Oop [16]=Oop off=142}表明EBX和栈中偏移量为16的位置各有一个Oop(普通对象指针), 有效范围从call指令开始到之后的142个指令

### 1.4.2. 安全点

GC Roots不断变化
- OopMap可以帮助HotSpot快速的完成GC Roots枚举, 但是程序运行过程中引用关系可能发生变化
- 部分指令可能引用OopMap变化，因此无法为每一条指令都生成OopMap，防止巨额空间成本
- HotSpot只在安全点SafePoint的代码位置生成OopMap，因此GC并非在任何指令位置停下来可以进行垃圾收集，而是强制要求必须执行到安全点后才能暂停
- 安全点位置原则是指令序列的复用，例如方法调用、循环跳转、异常跳转功能的指令才会产生安全点，生成对应的OopMap

如何让所有线程在GC时都停留在最近的安全点
- 抢先式中断: 垃圾收集时直接暂停所有线程，然后发现存在不在安全点的线程时，就恢复这个线程让它执行到安全点, 现在几乎没有JVM采用抢先式中断响应GC事件
- 现在JVM普遍采用主动式中断的方式，GC需要暂停用户线程时，不直接对线程进行操作，只是设置一个标志位
- HotSpot将某个内存页为不可读标志，各个线程在安全点时会去轮旋这个标志，HotSpot采用test指令方位这个内存页时产生缺页异常
- 在预先注册的异常处理器中挂起线程等待，这样只通过一条指令即可完成安全点轮询和触发线程中断停止

### 1.4.3. 安全区域

安全点保证了程序在执行时可以在不太长时间内就可以进入到垃圾收集过程的安全点
- 对于程序不执行例如线程阻塞状态时线程无法响应JVM的中断请求, 不能走到安全点挂起自己，这时需要引入安全区域Safe Region解决
- 安全区域值引用关系不会发生变化的一段代码片段，这个区域任何指令位置进行垃圾收集都是安全的,是扩展的安全点
- 当线程执行到安全区域代码时，对自己状态进行标识，JVM发起垃圾收集时不管这些线程，
- 当线程离开安全区域时，检查虚拟机是否完成根节点枚举或者其他暂停线程的阶段
- 如果没有则需要等待直到收到可以离开安全区域的信号，否则可以继续执行

### 1.4.4. 记忆集与卡表

分代收集理论中为了解决跨代引用问题，GC在新生代中建立了记忆集RememberedSet的数据结构避免将真个老年代加入到GC Roots扫描

记忆集是记录从非收集区域指向收集区域的指针集合的抽象数据结构，HotSpot采用卡表CardTable方式实现记忆集，每个记录精确到一个内存区域，表明该区域某个对象包含跨代指针

HotSpot默认的卡表元素对应的大小为512字节一个卡页, 这一页内存中只要一个对象包含跨代指针，就数组元素就为1，否则为0

在垃圾收集时，只要筛选卡表中变脏(1)的元素，将其加入到GC Roots中一并扫描, 以空间换时间

### 1.4.5. 写屏障

使用记忆集减少GC Roots扫描范围问题，使用写屏障解决卡表的维护和更新问题

何时变脏：变脏的时间点是在发生引用类型赋值的指令

如何变脏:
- 对于解释执行，则虚拟机负责字节码指令的执行，有充分的的介入空间
- 对于编译执行，则需要在机器代码层面将维护卡表的动作放入到每个赋值操作之中
- HotSpot采用写屏障Write Barrier维护卡表状态

写屏障:
- 写屏障可以看成对于对象引用赋值动作的AOP切面，在赋值前的称为写前屏障，在赋值后称为写后屏障，G1收集器出现之前JVM只使用写后屏障
- 应用写后屏障时，虚拟机为所有的复制操作指令oop_field_store指令生成对应的AOP指令
- 缺点1: 每次进行引用更新都会产生额外开销，但是对于Minor GC扫描真个老年代相比代价低得多
- 缺点2: 存在伪共享问题，即当多个线程操作多个的独立变量共享于同一个缓存行，会相互影响（写回、无效等）导致性能降低
  - 例如缓存行大小为64字节，一个卡表元素占用一个字节，64个卡表元素共享一个缓存行，则32KB内存中同时存在多个引用更新会导致性能降低
  - 解决办法是不采用无条件的写屏障，而是先检查卡表状态，只有卡表状态不是过时才将其变为脏

### 1.4.6. 并发的可达性分析

可达性算法需要全过程都基于一个保障一致性的快照中才能进行分析
- 在根节点枚举中，GC Roots数量和堆大小无关，并且相对于对象数量来说较少，在各种优化(OopMap)的停顿时间非常短暂且固定（不随着堆增长而增加）
- 从GC Roots下进行遍历对象图，停顿时间随着Java堆容量成正比关系, 停顿时间会线性增长
- 标记是所有追踪式收集器的共同特征，因此需要减少这部分停顿时间
- 遍历对象图的过程中，用户线程可能并发修改对象图结构，黑白表示有引用和无引用的对象，则并发修改可能白色被标记为黑色（可以容忍下次收集），可能黑色被标记为白色（不可容忍致命错误）
- Wilson 1994年证明只有同时满足一下才会将黑色对象误标记为白色对象（1）插入从黑色到白色的新引用（2）删除全部从灰色到白色的所有引用

解决赋值器（用户程序）并发扫描时的对象消失问题,只需要破坏任意一个条件：
- 增量更新(Incremental Update):
  - 破坏条件1
  - 当黑色对象插入了指向白色的引用就记录下来，并发扫描结束时将记录过的引用中黑色对象为根重新扫描
  - 即黑色对象插入了指向白色对象的引用，就将其变为灰色对象，重新扫描
- 原始快照(Snapshot At The Beginning, SATB):
  - 破坏条件2
  - 当灰色对象删除指向白色对象的引用时，记录这些引用，并发扫描时以这些灰色对象为根重新扫描
  - 即无论引用关系是否删除，按照刚开始扫描那一刻的对象图快照进行
- 对于引用关系删除和插入的记录都是通过写屏障记录的, HotSpot中CMS基于增量更新进行并发标记，而G1, Shenandoah使用原始快照进行并发标记


## 经典垃圾收集器

### Serial收集器

### ParNew收集器

### Parallel Scavenge收集器

### Parallel Old收集器

### CMS收集器

### Garbage First收集器

## 延迟垃圾收集器

###


